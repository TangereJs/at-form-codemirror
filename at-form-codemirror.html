<link rel="import" href="../polymer/polymer.html" />
<link rel="import" href="../code-mirror/code-mirror.html" />

<dom-module id="at-form-codemirror">
  <style>
    :host {
      display: block;
      position: relative;
    }
    
    #codeMirrorArea {
      position: relative;
      width: 100%;
      height: 100%;
    }
    
    #requiredValidationMessage {
      display: none;
    }
    
    #requiredValidationMessage[invalid] {
      display: block;
      position: relative;
    }
    
    .error {
      color: rgb(255, 0, 0);
      font-size: inherit;
      font: inherit;
    }
    
    .codeMirrorLabel {
      font-size: 14px;
      font-weight: bold;
      display: block;
      padding: 0 0 0.3em 0;
    }
    
    code-mirror {
      width: 100%;
      min-height: 100px;
      height: 100%;
    }
  </style>
  <template>
    <div id="wrapper" class="field">
      <div id="labelArea">
        <label class="codeMirrorLabel">{{label}}</label>
      </div>

      <code-mirror id="codeMirror"></code-mirror>

      <div id="requiredValidationMessage" class="required">
        <p class="error">This field is required</p>
      </div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'at-form-codemirror',
    properties: {
      value: {
        type: String,
        value: '',
        notify: true,
        observer: 'valueChanged'
      },
      mode: {
        type: String,
        value: 'htmlmixed',
        observer: 'modeChanged'
      },
      theme: {
        type: String,
        value: 'xq-light',
        observer: 'themeChanged'
      },
      tabSize: {
        type: Number,
        value: 2,
        observer: 'tabSizeChanged'
      },
      noLineNumbers: {
        type: Boolean,
        value: false,
        observer: 'noLineNumbersChanged'
      },
      required: {
        type: Boolean,
        value: false,
        observer: 'requiredChanged'
      },
      valid: {
        type: Boolean,
        value: true,
        readOnly: true,
        notify: true
      },
      disabled: {
        type: Boolean,
        value: false,
        observer: 'disabledChanged'
      },
      label: {
        type: String,
        value: '',
      }
    },
    _isReady: false,
    _cmInstance: undefined,
    _isMirrorChange: false,
    attached: function () {
      var cmInstance = this._cmInstace = this.$.codeMirror;
      var self = this;
      cmInstance.addEventListener('value-changed', function () {
        self._isMirrorChange = true;
        self.value = this.value;
        self._isMirrorChange = false;
      })

      this._isReady = true;

      if (!this.value) {
        // copy content from innerHtml/childNodes if no value was provided
        var tc = "";
        var c = Polymer.dom(this).childNodes;
        for (var i = 0; i < c.length; i++) {
          tc += c[i].textContent;
        }
        this.value = tc;
      }

      this.updateValidState();
    },
    refresh: function () {
      if (this._isReady) {
        this._cmInstace.refresh();
      }
    },
    focus: function () {
      if (this._isReady) {
        this._cmInstace.focus();
      }
    },
    valueChanged: function () {
      if (this._isReady) {
        if (!this._isMirrorChange) {
          this._cmInstace.value = this.value;
        }
        this.updateValidState();
      }
    },
    modeChanged: function () {
      if (this._isReady) {
        this._cmInstace.mode = this.mode;
      }
    },
    themeChanged: function () {
      if (this._isReady) {
        this._cmInstace.theme = this.theme;
      }
    },
    tabSizeChanged: function () {
      if (this._isReady) {
        this._cmInstace.tabSize = this.tabSize;
      }
    },
    noLineNumbersChanged: function () {
      if (this._isReady) {
        this._cmInstace.noLineNumbers = this.noLineNumbers;
      }
    },
    disabledChanged: function (oldValue, newValue) {
      if (this._isReady) {
        this._cmInstace.setOption('readOnly', this.disabled);
      }
    },
    requiredChanged: function (oldValue, newValue) {
      if (this._isReady) {
        this.updateValidState();
      }
    },
    updateValidState: function () {
      var validValue = this.required ? this.value !== undefined && this.value !== '' : true;

      if (!validValue) {
        this.$.requiredValidationMessage.setAttribute('invalid', true);
      } else {
        this.$.requiredValidationMessage.removeAttribute('invalid');
      }

      this.toggleClass('error', !validValue, this.$.wrapper);

      this._setValid(validValue);
    },
    autoGrow: function (input) {
      input.oninput = function () {
        this.style.height = 'auto';
        this.style.height = this.scrollHeight + 'px';
        window.scrollTo(window.scrollLeft, (this.scrollTop + this.scrollHeight));
      };

      var inputEvent = document.createEvent('Event');
      inputEvent.initEvent('input', true, true);
      input.dispatchEvent(inputEvent);
    }
  });
</script>