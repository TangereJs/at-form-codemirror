<link rel="import" href="../tangere/tangere.html">
<link rel="import" href="../at-theme/at-theme.html">
<link rel="import" href="../at-i18n/at-i18n-behavior.html">
<link rel="import" href="../code-mirror/code-mirror.html">
<link rel="import" href="../iron-label/iron-label.html">
<link rel="import" href="../at-form-behaviors/at-form-behaviors.html">
<link rel="import" href="at-form-codemirror-input-validation.html">

<dom-module id="at-form-codemirror">
  <template>
    <style include="at-form-common"></style>
    <style>
      :host * {
        box-sizing: border-box;
      }

      :host {
        @apply(--at-form-host);
      }

      #hint {
        min-height: 14px;
        margin-bottom: 8px;
      }
    </style>
    <div id="atContainer" class="at-container">
      <iron-label id="label" for="codeMirror">{{label}}</iron-label>
      <div id="contentContainer" class="at-content-container">
        <code-mirror id="codeMirror" max-lines="{{maxLines}}"></code-mirror>
      </div>
      <div id="hint"></div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'at-form-codemirror',
    behaviors: [Tangere.behaviors.i18n, Tangere.behaviors.formUIGeneric, Tangere.behaviors.AtFormCodeMirrorInputValidation ],
    properties: {
      /**
       * Element's label for element display purposes
       * @property label
       * @type String
       * @default ''
       */
      label: {
        type: String,
        value: '',
        title: 'Label'
      },

      /**
       * Hides element's label
       * @property hideLabel
       * @type Boolean
       * @default false
       */
      hideLabel: {
        type: Boolean,
        value: false,
        observer: '_hideLabelChanged',
        title: 'Do not show the label'
      },

      /**
       * Element's disabled state
       * @property disabled
       * @type Boolean
       * @default false
       */
      disabled: {
        type: Boolean,
        value: false,
        observer: '_disabledChanged',
        title: 'Field value can not be changed'
      },

      /**
      * Hides the element. When hidden nothing is displayed for the element
      * @property hide
      * @type Boolean
      * @default false
      */
      hide: {
        type: Boolean,
        value: false,
        observer: '_hideChanged',
        title: 'Field is invisible'
      },

      /**
       * Element's required state for element validation purposes
       * @property required
       * @type Boolean
       * @default false
       */
      required: {
        type: Boolean,
        value: false,
        observer: '_requiredChanged',
        title: 'Input required'
      },

      /**
       * Maximum number of characters across all lines allowed on the element. Use 0 (zero) for no limit
       * @property maxLines
       * @type Number
       * @default 0
       */
      maxChars: {
        type: Number,
        value: 0,
        observer: '_maxCharsChanged',
        title: 'Maximum number of characters'
      },

      /**
       * Elements value
       * @property value
       * @type String
       * @default ''
       */
      value: {
        type: String,
        value: '',
        observer: '_valueChanged',
        xtype: "textarea",
        title: 'Value'
      },

      /**
       * Maximum number of lines allowed on the element before vertical scroll bar is used
       * @property maxLines
       * @type Number
       * @default 14
       */
      maxLines: {
        type: Number,
        value: 14
      },

      /**
       * Syntax highlighting mode
       * @property mode
       * @type String
       * @default ''
       */
      mode: {
        type: String,
        value: 'htmlmixed',
        observer: '_modeChanged',
        xtype: "enum",
        enum: ["htmlmixed", "javascript", "css", "markdown", "sql", "xml", "liquid"]
      },

      /**
       * Color theme
       * @property theme
       * @type String
       * @default 'carbon'
       */
      theme: {
        type: String,
        value: 'carbon',
        observer: '_themeChanged',
        xtype: 'enum',
        xvaluelist: [
          { title: "Ambiance", value: "ambiance"},
          { title: "Blackboard", value: "blackboard"},
          { title: "Carbon", value: "carbon"},
          { title: "Cobalt", value: "cobalt"},
          { title: "Eclipse", value: "eclipse"},
          { title: "Elegant", value: "elegant"},
          { title: "Erlang dark", value: "erlang-dark"},
          { title: "Lesser Dark", value: "lesser-dark"},
          { title: "Midnight", value: "midnight"},
          { title: "Monokai", value: "monokai"},
          { title: "Neat", value: "neat"},
          { title: "Night", value: "night"},
          { title: "Rubyblue", value: "rubyblue"},
          { title: "Solarized", value: "solarized"},
          { title: "Twilight", value: "twilight"},
          { title: "Vibrant Ink", value: "vibrant-ink"},
          { title: "XQ Dark", value: "xq-dark"},
          { title: "XQ Light", value: "xq-light"}
        ]
      },

      /**
       * Tab size
       * @property tabSize
       * @type Number
       * @default 2
       */
      tabSize: {
        type: Number,
        value: 2,
        observer: '_tabSizeChanged'
      },

      /**
       * No line numbers. Set to true to hide line numbers
       * @property noLineNumbers
       * @type Boolean
       * @default false
       */
      noLineNumbers: {
        type: Boolean,
        value: false,
        observer: '_noLineNumbersChanged'
      }
    },
    $meta: [{
      title: "Code",
      type: "string",
      xtype: "code"
    }, {
      title: "JSON code",
      type: "object",
      xtype: "json"
    }],

    _hideLabelChanged: function(newValue, oldValue) {
      this.toggleClass("hidden", newValue, this.$.label);
    },

    ready: function() {
      var cmInstance = this._cmInstance = this.$.codeMirror;
      var self = this;
      cmInstance.addEventListener('value-changed', function(event) {
        // *ij* 09.08.2016
        // polymer-js lies about value-changed event not bubbling when bubbles = false under shadowDOM
        // underlying code-mirror value-changed event is non-bubbling but it bleeds into test code anyway
        // after reading this https://github.com/Polymer/polymer/issues/3226 it turns out this is correct shadowDOM behavior
        // event.stopPropagation() must be called so that correct behavior is produced
        event.stopPropagation();
        self.validate();
      });
      cmInstance.disabled = this.disabled;

      if (!this.value) {
        // copy content from innerHtml/childNodes if no value was provided
        var tc = "";
        var c = Polymer.dom(this).childNodes;
        for (var i = 0; i < c.length; i++) {
          tc += c[i].textContent;
        }
        this.value = tc;
      }

      this._isReady = true;
    },

    attached: function() {
      this._cmInstance.value = String(this.value);
    },

    _disabledChanged: function(newValue, oldValue) {
      var label = this.$.label;
      this.toggleClass('disabled', newValue, label);
      var contentContainer = this.$.contentContainer;
      this.toggleClass('disabled', newValue, contentContainer);

      if (this._isReady) {
        this._cmInstance.disabled = this.disabled;
        this.validate();
      }
    },

    _hideChanged: function(newValue, oldValue) {
      var atContainer = this.$.atContainer;
      this.toggleClass('hidden', newValue, atContainer);

      if (!newValue) {
        this.refresh();
        this.$.codeMirror.maxLinesChanged(this.maxLines, this.maxLines);
      }

      if (this._isReady) {
        this.validate();
      }
    },

    _requiredChanged: function(oldValue, newValue) {
      if (this._isReady) {
        this.validate();
      }
    },

    _maxCharsChanged: function(newValue, oldValue) {
      if (this._isReady) {
        this.validate();
      }
    },

    _valueChanged: function(newValue, oldValue) {
      // *ij* [object SpeechRecognition]
      // well at-core-mic recognition property is of that type and it needs to be strigified so there you have it
      if (this._isObject(newValue) || this._isArray(newValue) || this._isSpeechRecognition(newValue)) {
        newValue = JSON.stringify(newValue, null, ' ');
        this.value = newValue;
        return;
      }

      if (this._isReady) {
        if (newValue === null) {
          this._cmInstance.value = "";
        } else {
          this._cmInstance.value = String(this.value);
        }

        this._fireValueChangedEvent(this.value);
      }
    },

    _getFocusableElement: function() {
      return this.$.codeMirror;
    },

    validate: function (showError) {

      if (showError === undefined) { showError = this.autovalidate; }

      // validate must validate the current value
      var inputValue = this.$.codeMirror.value;

      if ((this.value === null && inputValue !== "") || (this.value !== null && this.value !== inputValue)) {
        this.value = inputValue;
      }

      var validationResult = this._validateBaseData();
      if (showError) { this._handleValidationResult(validationResult); }
      if (validationResult.isFinal) {
        return validationResult.isValid;
      }

      validationResult = this._validateData(this, this.value, this.T.bind(this));
      if (showError) { this._handleValidationResult(validationResult); }

      return validationResult.isValid;
    },

    _updateUIValidState: function(isValid) {
      var label = this.$.label;
      this.toggleClass('error', !isValid, label);
      var contentContainer = this.$.contentContainer;
      this.toggleClass('error', !isValid, contentContainer);
      var atContainer = this.$.atContainer;
      var codeMirrorCode = atContainer.getElementsByClassName('CodeMirror-lines')[0];
      this.toggleClass('error', !isValid, codeMirrorCode);
      var hint = this.$.hint;
      this.toggleClass('error', !isValid, hint);
    },

    refresh: function() {
      if (this._isReady) {
        this._cmInstance.refresh();
      }
    },

    focus: function() {
      if (this._isReady) {
        this._cmInstance.focus();
      }
    },

    _modeChanged: function() {
      if (this._isReady) {
        this._cmInstance.mode = this.mode;
      }
    },

    _themeChanged: function() {
      if (this._isReady) {
        this._cmInstance.theme = this.theme;
      }
    },

    _tabSizeChanged: function() {
      if (this._isReady) {
        this._cmInstance.tabSize = this.tabSize;
      }
    },

    _noLineNumbersChanged: function() {
      if (this._isReady) {
        this._cmInstance.noLineNumbers = this.noLineNumbers;
      }
    },

    _isObject: function(obj) {
      return Object.prototype.toString.call(obj) === "[object Object]";
    },
    _isSpeechRecognition: function(obj) {
      return Object.prototype.toString.call(obj) === "[object SpeechRecognition]";
    },
    _isArray: function(obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    }
  });
</script>
